# Outra maneira de calcular os efeitos
library(unrepx)
efeitos2 <- yates(y)
# Half normal plot
hnplot(efeitos2, half = T, method = "Lenth", ID = ME(efeitos2))
# Pareto PSE plot
parplot(efeitos2, method = "Lenth")
# Análise de significância dos efeitos
# Teste t via pseudo erro padrão de Lenth
eff.test(efeitos2, method = "Lenth")
#--------------------------------------------------------------------------------#
# Cálculos para fatorial não replicado via método de Lenth
s0 <- 1.5*median(abs(efeitos[-1]))
# Efeitos desprezíveis
efeitos_2.5 <- abs(efeitos) < 2.5*s0
efeitos_2.5 <- efeitos[efeitos_2.5 == TRUE]
# Pseudo erro padrão de Lenth
PSE <- 1.5*median(efeitos_2.5)
# t calculado
t0 <- efeitos[-1]/PSE
# Erro marginal
m <- N-1
ME <- qt(0.025, df = m/3, lower.tail = F)*PSE
# Erro marginal simultâneo
g <- (1+.95^(1/m))/2
SME <- qt(g, df = m/2)*PSE
# Data Frame efeitos
efeitos_pad <- data.frame(names(efeitos2), abs(efeitos2))
colnames(efeitos_pad) <- c("Fonte", "Efeito")
# Gráfico de efeitos padronizados
library(ggpubr)
ggbarplot(data = efeitos_pad,
y = "Efeito",
x = "Fonte",
col = "grey50",
fill = "lightgreen",
rotate = T,
sort.val = "asc") +
theme_bw() +
geom_hline(yintercept = c(ME, SME), col = "red", show.legend = T)
#--------------------------------------------------------------------------------#
## Fazendo os modelos
#Modelo Linear Completo
lm.completo <- lm(y ~ A*B*C*D, data = plan)
summary(lm.completo)
# Modelo de terceira ordem
lm3 <- lm(y ~.^3, data = plan)
summary(lm3)
# Reduzindo modelo -> Maneira mais adequada e modelo mais preciso
lm3_red <- step(lm3, direction = "backward", trace = FALSE)
summary(lm3_red)
# Modelo de segunda ordem
lm2 <- lm(y ~.^2, data = plan)
summary(lm2)
# Anova
anova <- aov(lm.completo)
summary(anova)
# Criando uma variável
modelo <- lm2
# Gráfico de Interação
plot_model(modelo, type = "pred", terms = c("A", "B", "C", "D"))
modelo
# Criando uma variável
modelo <- lm.completo
par(mfrow = c(3, 4))
contour(modelo, ~A1 + B1, image = TRUE)
contour(modelo, ~A1 + C1, image = TRUE)
contour(modelo, ~A1 + D1, image = TRUE)
contour(modelo, ~B1 + C1, image = TRUE)
contour(modelo, ~B1 + D1, image = TRUE)
contour(modelo, ~C1 + D1, image = TRUE)
persp(modelo, ~A1 + B1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~A1 + C1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~A1 + D1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~B1 + C1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~B1 + D1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~C1 + D1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
lm.completo
# Criando uma variável
modelo <- lm3_red
# Gráfico de Interação
plot_model(modelo, type = "pred", terms = c("A", "B", "C", "D"))
par(mfrow = c(3, 4))
contour(modelo, ~A1 + B1, image = TRUE)
contour(modelo, ~A1 + C1, image = TRUE)
contour(modelo, ~A1 + D1, image = TRUE)
contour(modelo, ~B1 + C1, image = TRUE)
contour(modelo, ~B1 + D1, image = TRUE)
contour(modelo, ~C1 + D1, image = TRUE)
persp(modelo, ~A1 + B1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~A1 + C1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~A1 + D1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~B1 + C1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~B1 + D1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~C1 + D1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
lm.completo <- lm(y ~ A*B*C*D, data = plan)
summary(lm.completo)
plan <- FrF2(nruns = 16, nfactors = 4, factor.names = c("A", "B", "C", "D"), randomize = F)
summary(plan)
# Respostas
y <- c(45, 71, 48, 65, 68, 60, 80, 65, 43, 100, 45, 104, 75, 86, 70, 96)
# Adicionando a resposta ao planejamento
plan$y <- y
View(plan)
lm.completo <- lm(y ~ A*B*C, data = plan)
summary(lm.completo)
lm.completo <- lm(y ~ A*B*C*D, data = plan)
summary(lm.completo)
plan <- expand.grid(A = c(-1, 1),
B = c(-1, 1),
C = c(-1, 1),
D = c(-1, 1))
plan
# Criação do experimento
plan <- expand.grid(A = c(-1, 1),
B = c(-1, 1),
C = c(-1, 1),
D = c(-1, 1))
# Respostas
y <- c(45, 71, 48, 65, 68, 60, 80, 65, 43, 100, 45, 104, 75, 86, 70, 96)
# Adicionando a resposta ao planejamento
plan$y <- y
#--------------------------------------------------------------------------------#
## Calculando os efeitos
X <- model.matrix(~A*B*C*D, data = plan[, -5])
N <- dim(X)[1]
efeitos <- crossprod(X,y)/(N/2)
# Outra maneira de calcular os efeitos
library(unrepx)
efeitos2 <- yates(y)
# Half normal plot
hnplot(efeitos2, half = T, method = "Lenth", ID = ME(efeitos2))
# Pareto PSE plot
parplot(efeitos2, method = "Lenth")
# Análise de significância dos efeitos
# Teste t via pseudo erro padrão de Lenth
eff.test(efeitos2, method = "Lenth")
#--------------------------------------------------------------------------------#
# Cálculos para fatorial não replicado via método de Lenth
s0 <- 1.5*median(abs(efeitos[-1]))
# Efeitos desprezíveis
efeitos_2.5 <- abs(efeitos) < 2.5*s0
efeitos_2.5 <- efeitos[efeitos_2.5 == TRUE]
# Pseudo erro padrão de Lenth
PSE <- 1.5*median(efeitos_2.5)
# t calculado
t0 <- efeitos[-1]/PSE
# Erro marginal
m <- N-1
ME <- qt(0.025, df = m/3, lower.tail = F)*PSE
# Erro marginal simultâneo
g <- (1+.95^(1/m))/2
SME <- qt(g, df = m/2)*PSE
# Data Frame efeitos
efeitos_pad <- data.frame(names(efeitos2), abs(efeitos2))
colnames(efeitos_pad) <- c("Fonte", "Efeito")
# Gráfico de efeitos padronizados
library(ggpubr)
ggbarplot(data = efeitos_pad,
y = "Efeito",
x = "Fonte",
col = "grey50",
fill = "lightgreen",
rotate = T,
sort.val = "asc") +
theme_bw() +
geom_hline(yintercept = c(ME, SME), col = "red", show.legend = T)
#--------------------------------------------------------------------------------#
## Fazendo os modelos
#Modelo Linear Completo
lm.completo <- lm(y ~ A*B*C*D, data = plan)
summary(lm.completo)
# Modelo de terceira ordem
lm3 <- lm(y ~.^3, data = plan)
summary(lm3)
# Reduzindo modelo -> Maneira mais adequada e modelo mais preciso
lm3_red <- step(lm3, direction = "backward", trace = FALSE)
summary(lm3_red)
# Modelo de segunda ordem
lm2 <- lm(y ~.^2, data = plan)
summary(lm2)
# Anova
anova <- aov(lm.completo)
summary(anova)
# Criando uma variável
modelo <- lm3_red
# Gráfico de Interação
plot_model(modelo, type = "pred", terms = c("A", "B", "C", "D"))
# Superfície de Resposta e Gráfico de Controle
par(mfrow = c(3, 4))
contour(modelo, ~A1 + B1, image = TRUE)
contour(modelo, ~A1 + C1, image = TRUE)
contour(modelo, ~A1 + D1, image = TRUE)
contour(modelo, ~B1 + C1, image = TRUE)
contour(modelo, ~B1 + D1, image = TRUE)
contour(modelo, ~C1 + D1, image = TRUE)
persp(modelo, ~A1 + B1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~A1 + C1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~A1 + D1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~B1 + C1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~B1 + D1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~C1 + D1, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
par(mfrow = c(3, 4))
contour(modelo, ~A + B, image = TRUE)
contour(modelo, ~A + C, image = TRUE)
contour(modelo, ~A + D, image = TRUE)
contour(modelo, ~B + C, image = TRUE)
contour(modelo, ~B + D, image = TRUE)
contour(modelo, ~C + D, image = TRUE)
persp(modelo, ~A + B, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~A + C, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~A + D, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~B + C, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~B + D, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~C + D, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
par(mfrow = c(4, 3))
contour(modelo, ~A + B, image = TRUE)
contour(modelo, ~A + C, image = TRUE)
contour(modelo, ~A + D, image = TRUE)
contour(modelo, ~B + C, image = TRUE)
contour(modelo, ~B + D, image = TRUE)
contour(modelo, ~C + D, image = TRUE)
persp(modelo, ~A + B, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~A + C, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~A + D, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~B + C, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~B + D, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~C + D, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
# Gráfico de Interação
plot_model(modelo, type = "pred", terms = c("A", "B", "C", "D"))
ggbarplot(data = efeitos_pad,
y = "Efeito",
x = "Fonte",
col = "grey50",
fill = "lightgreen",
rotate = T,
sort.val = "asc") +
theme_bw() +
geom_hline(yintercept = c(ME, SME), col = "red", show.legend = T)
hnplot(efeitos2, half = T, method = "Lenth", ID = ME(efeitos2))
parplot(efeitos2, method = "Lenth")
plan <- FrF2(nruns = 16, nfactors = 4, factor.names = c("A", "B", "C", "D"), randomize = F)
summary(plan)
# Criação do experimento
plan <- expand.grid(A = c(-1, 1),
B = c(-1, 1),
C = c(-1, 1),
D = c(-1, 1))
# Respostas
y <- c(45, 71, 48, 65, 68, 60, 80, 65, 43, 100, 45, 104, 75, 86, 70, 96)
# Adicionando a resposta ao planejamento
plan$y <- y
#--------------------------------------------------------------------------------#
## Calculando os efeitos
X <- model.matrix(~A*B*C*D, data = plan[, -5])
N <- dim(X)[1]
efeitos <- crossprod(X,y)/(N/2)
# Outra maneira de calcular os efeitos
library(unrepx)
efeitos2 <- yates(y)
# Half normal plot
hnplot(efeitos2, half = T, method = "Lenth", ID = ME(efeitos2))
# Half normal plot
hnplot(efeitos2, half = T, method = "Lenth", ID = ME(efeitos2))
# Pareto PSE plot
parplot(efeitos2, method = "Lenth")
# Criando uma variável
modelo <- lm.completo
# Criação do experimento
plan <- expand.grid(A = c(-1, 1),
B = c(-1, 1),
C = c(-1, 1),
D = c(-1, 1))
# Respostas
y <- c(45, 71, 48, 65, 68, 60, 80, 65, 43, 100, 45, 104, 75, 86, 70, 96)
# Adicionando a resposta ao planejamento
plan$y <- y
#--------------------------------------------------------------------------------#
## Calculando os efeitos
X <- model.matrix(~A*B*C*D, data = plan[, -5])
N <- dim(X)[1]
efeitos <- crossprod(X,y)/(N/2)
# Outra maneira de calcular os efeitos
library(unrepx)
efeitos2 <- yates(y)
# Half normal plot
hnplot(efeitos2, half = T, method = "Lenth", ID = ME(efeitos2))
# Pareto PSE plot
parplot(efeitos2, method = "Lenth")
# Análise de significância dos efeitos
# Teste t via pseudo erro padrão de Lenth
eff.test(efeitos2, method = "Lenth")
#--------------------------------------------------------------------------------#
# Cálculos para fatorial não replicado via método de Lenth
s0 <- 1.5*median(abs(efeitos[-1]))
# Efeitos desprezíveis
efeitos_2.5 <- abs(efeitos) < 2.5*s0
efeitos_2.5 <- efeitos[efeitos_2.5 == TRUE]
# Pseudo erro padrão de Lenth
PSE <- 1.5*median(efeitos_2.5)
# t calculado
t0 <- efeitos[-1]/PSE
# Erro marginal
m <- N-1
ME <- qt(0.025, df = m/3, lower.tail = F)*PSE
# Erro marginal simultâneo
g <- (1+.95^(1/m))/2
SME <- qt(g, df = m/2)*PSE
# Data Frame efeitos
efeitos_pad <- data.frame(names(efeitos2), abs(efeitos2))
colnames(efeitos_pad) <- c("Fonte", "Efeito")
# Gráfico de efeitos padronizados
library(ggpubr)
ggbarplot(data = efeitos_pad,
y = "Efeito",
x = "Fonte",
col = "grey50",
fill = "lightgreen",
rotate = T,
sort.val = "asc") +
theme_bw() +
geom_hline(yintercept = c(ME, SME), col = "red", show.legend = T)
#--------------------------------------------------------------------------------#
## Fazendo os modelos
#Modelo Linear Completo
lm.completo <- lm(y ~ A*B*C*D, data = plan)
summary(lm.completo)
# Modelo de terceira ordem
lm3 <- lm(y ~.^3, data = plan)
summary(lm3)
# Reduzindo modelo -> Maneira mais adequada e modelo mais preciso
lm3_red <- step(lm3, direction = "backward", trace = FALSE)
summary(lm3_red)
# Modelo de segunda ordem
lm2 <- lm(y ~.^2, data = plan)
summary(lm2)
# Anova
anova <- aov(lm.completo)
summary(anova)
# Criando uma variável
modelo <- lm.completo
# Gráfico de Interação
plot_model(modelo, type = "pred", terms = c("A", "B", "C", "D"))
# Superfície de Resposta e Gráfico de Controle
par(mfrow = c(4, 3))
contour(modelo, ~A + B, image = TRUE)
contour(modelo, ~A + C, image = TRUE)
contour(modelo, ~A + D, image = TRUE)
contour(modelo, ~B + C, image = TRUE)
contour(modelo, ~B + D, image = TRUE)
contour(modelo, ~C + D, image = TRUE)
persp(modelo, ~A + B, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~A + C, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~A + D, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~B + C, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~B + D, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
persp(modelo, ~C + D, zlab = "Ra [um]", col = rainbow(50), contours = ("colors"))
summary(lm3_red)
summary(lm3)
summary(lm.completo)
teste <- summary(lm.completo)
View(teste)
View(teste)
summary(lm3_red)
summary(anova)
# Anova
anova <- aov(lm3_red)
summary(anova)
# Planejamento
plan2 <- FrF2(nruns = 4, nfactors = 2, replications = 3, factor.names = c("C", "T"), randomize = F)
summary(plan2)
# Adicionando resposta
plan2$y <- y
# Modelo linear via FrF2
lm1 <- lm(y ~ C*T, data = plan2)
summary(lm1)
# Via expand.grid e lm
lm2 <- lm(y ~ C*T, data = plan)
summary(lm1)
# ANOVA
anova1 <- aov(lm2)
summary(anova1)
# Planejamento Fatorial 2^2
#--------------------------------------------------------------------------------#
### Construção do Experimento
# Níveis
levels <- c(-1, 1)
# Planejamento
plan <- expand.grid(levels, levels)
plan <- rbind(plan, plan, plan)
# Nomes das colunas
colnames(plan) <- c("C", "T")
# Respostas
y <- c(26.6, 40.9, 11.8, 34.0,
22.0, 36.4, 15.9, 29.0,
22.8, 36.7, 14.3, 33.6)
plan$y <- y
plan
#--------------------------------------------------------------------------------#
### Análise do Experimento
# Matriz do Planejamento
X <- model.matrix(~C*T, data = plan[,-3])
# Efeitos
efeitos <- crossprod(X, y)/(3*2^2/2)
# Coeficientes
coef <- efeitos/2
# Valores ajustados
fitted <- X%*%coef
# Resíduos
resi <- y - fitted
# Número de ensaios (N) e de termos no modelo (r)
N <- dim(X)[1]
r <- dim(X)[2]
## Soma dos quadrados
# SS dos resíduos
SSE <- sum(resi^2)
# SS total
SST <- sum(y^2) - sum(y)^2/N
## Graus de liberdade
# Dos erros
DFE <- N - r
# Total
DFT <- N - 1
## Média dos quadrados
# Dos erros
MSE <- SSE/DFE
# Total
MST <- SST/DFT
# t calculado
t0 <- coef/sqrt(MSE/N)
t0
# t crítico
t_critico <- qt(0.05, df = DFE, lower.tail = F)
t_critico
# pvalue
pvalue <- 2*pt(abs(t0), df = DFE, lower.tail = F)
pvalue
# Dataframe resumo do teste t
testet <- data.frame(coef, rep(sqrt(MSE/N), 4), t0, pvalue)
colnames(testet) <- c("Coef", "SE_coef", "t0", "p-value")
# Coef de determinação múltipla
R2 <- 1 - SSE/SST
R2_aj <- 1 - MSE/MST
#--------------------------------------------------------------------------------#
## Anova
# soma dos quadrados dos efeitos
SS_x <- crossprod(X[,-1], y)^2/N
# Média dos quadrados dos efeitos
MS_x <- SS_x/1
# F Calculado
F0 <- MS_x/MSE
F0
# pvalor
p <- pf(F0, 1, DFE, lower.tail = F)
p
# Tabela resumo ANOVA
Source <- c("C", "T", "CT", "Erro", "Total")
SS <- c(SS_x, SSE, SST)
DF <- c(rep(1, 3), DFE, DFT)
MS <- c(MS_x, MSE, MST)
F0 <- c(F0, NA, NA)
pvalor <- c(p, NA, NA)
ANOVA <- data.frame(SS, DF, MS, F0, pvalor)
rownames(ANOVA) <- Source
ANOVA
#--------------------------------------------------------------------------------#
## Mínimos quadrados matricial
# Multiplicando X transposta por X
t(X)%*%X
# Inversa do resultado anterior
solve(t(X)%*%X)
# Multiplicando X transposta por y
t(X)%*%y
# Obtendo os coeficientes
beta_mat <- solve(t(X)%*%X)%*%t(X)%*%y
beta_mat
# Previsão para todos os resultados experimentais
y_hay <- X%*%beta_mat
# Previsão para valores de C e T específicos
# C = 0, T = 0.5
x_esp <- matrix(c(1, 0, 0.5, 0), nrow = 4, ncol = 1)
y_esp_hat <- t(x_esp)%*%beta_mat
y_esp_hat
#--------------------------------------------------------------------------------#
## Análise via pacote FrF2 e comando lm
# via FrF2
install.packages("FrF2")
library(FrF2)
# Planejamento
plan2 <- FrF2(nruns = 4, nfactors = 2, replications = 3, factor.names = c("C", "T"), randomize = F)
summary(plan2)
# Adicionando resposta
plan2$y <- y
# Modelo linear via FrF2
lm1 <- lm(y ~ C*T, data = plan2)
summary(lm1)
# Via expand.grid e lm
lm2 <- lm(y ~ C*T, data = plan)
summary(lm1)
# ANOVA
anova1 <- aov(lm2)
summary(anova1)
install.packages("FrF2")
setwd("~/Mestrado/Disciplinas/FT045 - Tópicos em Tecnologia para Informação II/Trabalho 1/Códigos")
install.packages("PNADcIBGE")
library(PNADcIBGE)
# Criação do dataset
dadosPNADc <- get_pnadc(year = 2021, quarter = 2)
dadosPNADc
# Criação do dataset
dadosPNADc <- get_pnadc(year = 2021, quarter = 2, design = FALSE)
dadosPNADc
